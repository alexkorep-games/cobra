<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Project Cobra</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        color: #ffff00; /* Bright Yellow */
        font-family: "Press Start 2P", cursive;
        font-size: 10px; /* Base size, scale as needed */
        line-height: 1.6;
      }

      #container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        image-rendering: pixelated; /* Attempt pixelated look */
        image-rendering: crisp-edges;
      }

      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        pointer-events: none; /* Allow clicks through to canvas if needed */
        box-sizing: border-box;
        padding: 10px;
      }

      .top-bar,
      .bottom-bar {
        width: 100%;
        box-sizing: border-box;
      }

      .top-bar {
        text-align: center;
        padding: 5px 0;
        border-bottom: 2px solid #ffff00; /* Yellow border */
        margin-bottom: 10px;
      }

      .center-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        font-size: 1.5em;
        color: #00ff00; /* Bright Green */
        width: 80%; /* Prevent very long lines */
      }
      .center-text.small {
        font-size: 1.2em;
        line-height: 1.8;
        color: #ffffff; /* White for credits/stats */
      }

      .bottom-bar {
        border: 2px solid #ffff00; /* Yellow border */
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: space-between;
        padding: 5px;
        min-height: 80px; /* Adjust as needed */
      }

      /* --- HUD Styles (unchanged from original) --- */
      .hud-left,
      .hud-right {
        display: flex;
        flex-direction: column;
        width: 30%;
        border: 1px solid #00ff00; /* Green border */
        padding: 3px;
        font-size: 0.8em;
      }
      .hud-center {
        width: 35%;
        border: 1px solid #ffff00; /* Yellow border */
        display: flex;
        justify-content: center;
        align-items: center;
        background-image: radial-gradient(#003300 1px, transparent 1px),
          radial-gradient(#003300 1px, transparent 1px);
        background-size: 10px 10px;
        background-position: 0 0, 5px 5px;
      }
      .scanner-shape {
        width: 60%;
        height: 60%;
        border: 1px solid #ffff00;
        position: relative;
      }
      .scanner-shape::before,
      .scanner-shape::after {
        content: "";
        position: absolute;
        border-top: 1px solid #ffff00;
        left: 10%;
        right: 10%;
      }
      .scanner-shape::before {
        top: 30%;
      }
      .scanner-shape::after {
        bottom: 0%;
        width: 30%;
        left: 35%;
      }
      .hud-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 1px;
        white-space: nowrap;
      }
      .hud-label {
        color: #ff0000;
        margin-right: 5px;
      }
      .hud-bar {
        flex-grow: 1;
        border: 1px solid #004400;
        background-color: #002200;
        position: relative;
        height: 6px;
        margin-top: 2px;
      }
      .hud-bar-fill {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        background-color: #00ff00;
      }
      .hud-bar-fill.red {
        background-color: #ff0000;
      }
      .hud-value {
        color: #00ff00;
      }
      #fore-shield-fill {
        width: 80%;
      }
      #aft-shield-fill {
        width: 80%;
      }
      #fuel-fill {
        width: 100%;
      }
      #cabin-temp-fill {
        width: 10%;
        background-color: #00ff00;
      }
      #laser-temp-fill {
        width: 5%;
        background-color: #ff0000;
      }
      /* --- End HUD Styles --- */

      .hidden {
        display: none;
      }

      /* Commander Stats Styling */
      #stats-screen {
        color: #cc66ff; /* Magenta-like color */
        background-color: #000000;
        border: 2px solid #cc66ff;
        padding: 20px;
        font-size: 1.2em;
        box-sizing: border-box;
      }
      #stats-screen h2 {
        color: #ffffff;
        text-align: center;
        margin-top: 0;
        margin-bottom: 15px;
      }
      #stats-screen p {
        margin: 5px 0;
      }
      #stats-screen strong {
        color: #00ff00;
        margin-right: 10px;
        display: inline-block;
        min-width: 120px;
      }
      #stats-screen .equipment {
        margin-top: 15px;
        color: #ffff00;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="eliteCanvas"></canvas>

      <div class="overlay">
        <div class="top-bar">
          <span id="title-text">--- PROJECT COBRA ---</span>
          <span id="bounty-text" class="hidden">BOUNTY: 5.0 Cr</span>
          <span id="view-text" class="hidden">Front View</span>
        </div>

        <!-- Central Text Area -->
        <div id="press-key-text" class="center-text hidden">
          Press any key to start game
        </div>
        <div id="credits-text" class="center-text small hidden">
          Game Copyright:-<br />
          Bell & Braben<br />
          Code Copyright:-<br />
          Realtime Games<br />
          Software Ltd<br />
          Written by:-<br />
          Andy Onions<br />
          Cracked by:-<br />
          Key Software
        </div>
        <div id="stats-screen" class="center-text small hidden">
          <h2>COMMANDER JAMESON</h2>
          <p><strong>System:</strong> LAVE</p>
          <p><strong>Hypersystem:</strong> LAVE</p>
          <p><strong>Fuel:</strong> 7.0 Light Years</p>
          <p><strong>Cash:</strong> 100.0 Credits</p>
          <p><strong>Legal Status:</strong> Clean</p>
          <p><strong>Rating:</strong> Harmless</p>
          <p class="equipment"><strong>EQUIPMENT:</strong></p>
          <p>Missile (3)</p>
          <p>Pulse Laser (Fore)</p>
        </div>
        <div id="leaving-text" class="center-text small hidden">
          Leaving Space Station
        </div>

        <!-- Bottom HUD (always visible for now) -->
        <div class="bottom-bar">
          <div class="hud-left">
            <div class="hud-item">
              <span class="hud-label">FORE-SHIELD</span>
              <div class="hud-bar">
                <div id="fore-shield-fill" class="hud-bar-fill"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">AFT-SHIELD</span>
              <div class="hud-bar">
                <div id="aft-shield-fill" class="hud-bar-fill"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">FUEL</span>
              <div class="hud-bar">
                <div id="fuel-fill" class="hud-bar-fill"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">CABIN TEMP</span>
              <div class="hud-bar">
                <div id="cabin-temp-fill" class="hud-bar-fill"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">LASER TEMP</span>
              <div class="hud-bar">
                <div id="laser-temp-fill" class="hud-bar-fill red"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">ALTITUDE</span>
              <div class="hud-bar"></div>
            </div>
            <div class="hud-item">
              <span class="hud-label">MISSILES</span
              ><span class="hud-value"> M M M M</span>
            </div>
          </div>
          <div class="hud-center"><div class="scanner-shape"></div></div>
          <div class="hud-right">
            <div class="hud-item">
              <span class="hud-label">SPEED</span>
              <div class="hud-bar">
                <div class="hud-bar-fill" style="width: 10%"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">ROLL</span>
              <div class="hud-bar">
                <div class="hud-bar-fill" style="width: 50%"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">DIVE/CLIMB</span>
              <div class="hud-bar">
                <div class="hud-bar-fill" style="width: 50%"></div>
              </div>
            </div>
            <div
              class="hud-item"
              style="justify-content: center; margin-top: 5px"
            >
              <span style="border: 1px solid #00ff00; padding: 2px 5px">1</span>
              <span
                style="
                  border: 1px solid #00ff00;
                  padding: 2px 5px;
                  margin: 0 5px;
                "
                >2</span
              >
              <span style="border: 1px solid #00ff00; padding: 2px 5px">3</span>
              <span
                style="
                  border: 1px solid #ffff00;
                  border-radius: 50%;
                  width: 15px;
                  height: 15px;
                  display: inline-block;
                  margin-left: 10px;
                "
              ></span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Audio Elements -->
    <audio id="introMusic" loop>
      <source src="elite_intro_music.mp3" type="audio/mpeg" />
      Your browser does not support the audio element. (Needs
      elite_intro_music.mp3)
    </audio>
    <audio id="undockSound">
      <source src="undocking_sound.mp3" type="audio/mpeg" />
      Your browser does not support the audio element. (Needs
      undocking_sound.mp3)
    </audio>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.164.1/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      // --- Constants ---
      const SHIP_DISPLAY_DURATION = 4.0; // Seconds

      // --- Base Scene Class (Optional but good practice) ---
      class SceneBase {
        constructor(game) {
          this.game = game; // Reference to the main game manager
          this.scene = game.scene;
          this.camera = game.camera;
          this.renderer = game.renderer;
        }
        enter() {
          console.log(`Entering ${this.constructor.name}`);
        } // Called when scene becomes active
        exit() {
          console.log(`Exiting ${this.constructor.name}`);
        } // Called when scene is left
        update(deltaTime) {} // Called every frame
        handleInput(event) {} // Optional input handling for the scene
      }

      // --- Title Scene ---
      class TitleScene extends SceneBase {
        constructor(game) {
          super(game);
          this.titleShips = game.assets.titleShips; // Array of ships
          this.planet = game.assets.planet;
          this.stars = game.assets.stars;
          this.pressKeyText = game.domElements.pressKeyText;
          this.introMusic = game.audio.introMusic;
          this.keyProcessed = false;

          this.currentShipIndex = 0;
          this.shipDisplayTimer = 0;
        }

        enter() {
          super.enter();
          this.keyProcessed = false;
          this.pressKeyText.classList.remove("hidden");

          // Hide all title ships initially
          this.titleShips.forEach((ship) => (ship.visible = false));

          // Show the first ship
          this.currentShipIndex = 0;
          this.shipDisplayTimer = 0;
          if (this.titleShips.length > 0) {
            const firstShip = this.titleShips[this.currentShipIndex];
            firstShip.visible = true;
            firstShip.position.set(-3, 0, 0); // Reset position
            firstShip.rotation.set(0, Math.PI, 0); // Reset rotation (start facing camera maybe?)
          }

          // Setup planet and stars
          this.planet.visible = true;
          this.stars.visible = true;
          this.planet.position.set(7, 0, -5);
          this.planet.scale.set(1, 1, 1);

          this.game.domElements.titleText.classList.remove("hidden");
          this.game.domElements.viewText.classList.add("hidden");

          this.introMusic.currentTime = 0; // Rewind
          this.introMusic
            .play()
            .catch((e) => console.warn("Title audio play failed:", e));
        }

        exit() {
          super.exit();
          this.pressKeyText.classList.add("hidden");

          // Hide the currently shown ship
          if (this.titleShips.length > 0) {
            this.titleShips[this.currentShipIndex].visible = false;
          }

          this.planet.visible = false; // Hide other title assets
          // Keep stars visible if next scene uses them
          this.introMusic.pause();
        }

        update(deltaTime) {
          // Rotate stars
          if (this.stars) {
            this.stars.rotation.y += 0.01 * deltaTime;
          }

          // Animate and cycle ships
          if (this.titleShips.length > 0) {
            const currentShip = this.titleShips[this.currentShipIndex];

            // Rotate current ship
            currentShip.rotation.y += 0.5 * deltaTime;
            currentShip.rotation.x += 0.25 * deltaTime;

            // Update timer
            this.shipDisplayTimer += deltaTime;

            // Check if it's time to switch
            if (this.shipDisplayTimer >= SHIP_DISPLAY_DURATION) {
              // Hide current ship
              currentShip.visible = false;

              // Move to next ship index (and wrap around)
              this.currentShipIndex =
                (this.currentShipIndex + 1) % this.titleShips.length;

              // Get the new ship
              const nextShip = this.titleShips[this.currentShipIndex];

              // Show the new ship and reset its state
              nextShip.visible = true;
              nextShip.position.set(-3, 0, 0); // Reset position
              nextShip.rotation.set(0, Math.PI, 0); // Reset rotation

              // Reset timer
              this.shipDisplayTimer = 0;
            }
          }
        }

        handleInput(event) {
          if (!this.keyProcessed && event.type === "keydown") {
            this.keyProcessed = true;
            this.game.switchScene("credits");
          }
        }
      }

      // --- Credits Scene (Unchanged) ---
      class CreditsScene extends SceneBase {
        constructor(game) {
          super(game);
          this.creditsText = game.domElements.creditsText;
          this.timeoutId = null;
        }

        enter() {
          super.enter();
          this.creditsText.classList.remove("hidden");
          this.game.assets.stars.visible = true; // Keep stars visible

          this.timeoutId = setTimeout(() => {
            this.game.switchScene("stats");
          }, 3000); // Duration of Credits screen
        }

        exit() {
          super.exit();
          this.creditsText.classList.add("hidden");
          clearTimeout(this.timeoutId); // Clear timer if exiting early
        }

        update(deltaTime) {
          if (this.game.assets.stars) {
            this.game.assets.stars.rotation.y += 0.01 * deltaTime; // Keep stars rotating
          }
        }
      }

      // --- Stats Scene ---
      class StatsScene extends SceneBase {
        constructor(game) {
          super(game);
          this.statsScreen = game.domElements.statsScreen;
          this.timeoutId = null;
        }

        enter() {
          super.enter();
          this.statsScreen.classList.remove("hidden");
          this.game.assets.stars.visible = true; // Keep stars visible

          // Automatically transition after a delay
          this.timeoutId = setTimeout(() => {
            this.game.switchScene("undocking");
          }, 5000); // Duration of Stats screen
        }

        exit() {
          super.exit();
          this.statsScreen.classList.add("hidden");
          clearTimeout(this.timeoutId);
        }

        update(deltaTime) {
          if (this.game.assets.stars) {
            this.game.assets.stars.rotation.y += 0.01 * deltaTime; // Keep stars rotating
          }
        }
      }

      // --- Undocking Scene ---
      class UndockingScene extends SceneBase {
        constructor(game) {
          super(game);
          this.leavingText = game.domElements.leavingText;
          this.undockSound = game.audio.undockSound;
          this.undockingSquares = game.assets.undockingSquares;
          this.timeoutId = null;
        }

        enter() {
          super.enter();
          this.leavingText.classList.remove("hidden");
          this.game.domElements.titleText.classList.add("hidden"); // Hide ELITE title
          this.game.domElements.viewText.classList.remove("hidden"); // Show Front View

          this.game.assets.stars.visible = true; // Keep stars visible

          // Make squares visible and reset positions
          this.undockingSquares.forEach((square, i) => {
            square.position.z = -i * 5; // Reset initial spread
            square.visible = true;
          });

          this.undockSound.currentTime = 0;
          this.undockSound
            .play()
            .catch((e) => console.warn("Undock audio play failed:", e));

          // Automatically transition after a delay
          this.timeoutId = setTimeout(() => {
            this.game.switchScene("space_flight");
          }, 3500); // Duration slightly longer than sound
        }

        exit() {
          super.exit();
          this.leavingText.classList.add("hidden");
          this.undockingSquares.forEach((s) => (s.visible = false)); // Hide squares
          clearTimeout(this.timeoutId);
          // Don't stop undock sound immediately, let it finish
        }

        update(deltaTime) {
          // Undocking animation
          const speed = 20.0; // Adjust speed as needed
          this.undockingSquares.forEach((s, i) => {
            s.position.z += speed * deltaTime; // Move squares towards camera
            // Reset position when past camera (adjust threshold and reset distance)
            if (s.position.z > this.camera.position.z + 5) {
              s.position.z =
                -this.undockingSquares.length * 5 +
                (5 - (s.position.z - (this.camera.position.z + 5))); // Reset behind the farthest square
            }
          });

          if (this.game.assets.stars) {
            this.game.assets.stars.rotation.y += 0.01 * deltaTime; // Keep stars rotating
          }
        }
      }

      // --- Space Flight Scene ---
      class SpaceFlightScene extends SceneBase {
        constructor(game) {
          super(game);
          this.planet = game.assets.planet;
          this.stars = game.assets.stars;
        }

        enter() {
          super.enter();
          this.game.domElements.titleText.classList.add("hidden");
          this.game.domElements.viewText.classList.remove("hidden");

          // Position planet as a distant object
          this.planet.position.set(0, 15, -60); // Further away, slightly up
          this.planet.scale.set(5, 5, 5); // Make it look larger/closer than a star
          this.planet.visible = true;
          this.stars.visible = true;

          console.log("Entered Space Flight Scene. Intro sequence complete.");
          // Future: Enable player controls, AI, etc.
        }

        exit() {
          super.exit();
          this.planet.visible = false; // Hide if transitioning elsewhere
        }

        update(deltaTime) {
          // Keep stars rotating slowly
          if (this.stars) {
            this.stars.rotation.y += 0.01 * deltaTime;
          }
          // Maybe add slow drift to planet or other background elements
        }
      }

      // --- Game Manager Class ---
      class Game {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.clock = new THREE.Clock();

          this.assets = {
            titleShips: [],
            planet: null,
            stars: null,
            undockingSquares: [],
          };

          this.audio = {
            introMusic: null,
            undockSound: null,
          };

          this.domElements = {
            pressKeyText: document.getElementById("press-key-text"),
            creditsText: document.getElementById("credits-text"),
            statsScreen: document.getElementById("stats-screen"),
            leavingText: document.getElementById("leaving-text"),
            titleText: document.getElementById("title-text"),
            viewText: document.getElementById("view-text"),
            // Add other HUD elements if they need direct manipulation
          };

          this.scenes = {};
          this.currentScene = null;
          this.currentSceneName = null;

          this.animate = this.animate.bind(this);
          this.onWindowResize = this.onWindowResize.bind(this);
          this.handleGlobalInput = this.handleGlobalInput.bind(this);
        }

        init() {
          // --- Core Three.js Setup ---
          this.scene = new THREE.Scene();
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.camera.position.z = 15; // Default camera position

          const canvas = document.getElementById("eliteCanvas");
          this.renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: false,
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setClearColor(0x000000);

          // --- Lighting ---
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
          this.scene.add(ambientLight);
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
          directionalLight.position.set(1, 1, 1);
          this.scene.add(directionalLight);

          this.createAssets(); // Create all assets including the ships

          // --- Audio ---
          this.audio.introMusic = document.getElementById("introMusic");
          this.audio.undockSound = document.getElementById("undockSound");

          // --- Instantiate Scenes ---
          this.scenes.title = new TitleScene(this);
          this.scenes.credits = new CreditsScene(this);
          this.scenes.stats = new StatsScene(this);
          this.scenes.undocking = new UndockingScene(this);
          this.scenes.space_flight = new SpaceFlightScene(this);

          // --- Event Listeners ---
          window.addEventListener("resize", this.onWindowResize, false);
          window.addEventListener("keydown", this.handleGlobalInput, false);

          this.switchScene("title");
          this.animate();
        }

        // --- Helper for creating ships with vertex colors ---
        createColoredShip(vertices, indices) {
          const geometry = new THREE.BufferGeometry();
          const colors = [];
          const yellowColor = [1, 1, 0];
          for (let i = 0; i < indices.length / 3; i++) {
            // Use yellowColor for all 3 vertices of the face
            colors.push(...yellowColor, ...yellowColor, ...yellowColor);
          }
          geometry.setIndex(indices);
          geometry.setAttribute(
            "position",
            new THREE.BufferAttribute(new Float32Array(vertices), 3)
          );
          geometry.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(colors, 3)
          );
          geometry.computeVertexNormals(); // Good practice

          const material = new THREE.MeshBasicMaterial({
            vertexColors: true,
            side: THREE.DoubleSide, // Ensure solid appearance
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.scale.set(0.8, 0.8, 0.8); // Apply consistent scaling
          mesh.visible = false; // Start hidden
          return mesh;
        }

        createAssets() {
          const shipScale = 0.8; // Common scale factor

          // --- Ship 1: Original Cobra-like ---
          const cobraVertices = [
            0, 1, 3, -4, 0, 0, 4, 0, 0, -3, -1, 0, 3, -1, 0, 0, 0.5, -4, 0,
            -0.5, -4, -4, -0.5, -3.5, 4, -0.5, -3.5,
          ];
          const cobraIndices = [
            0, 1, 2, 0, 3, 1, 0, 2, 4, 3, 1, 7, 3, 7, 6, 1, 5, 7, 4, 2, 8, 4, 8,
            6, 2, 5, 8, 3, 6, 4, 5, 7, 6, 5, 8, 7, 5, 6, 8,
          ];
          const ship1 = this.createColoredShip(cobraVertices, cobraIndices);
          this.assets.titleShips.push(ship1);
          this.scene.add(ship1);

          // --- Ship 2: Simple Wedge/Fighter ---
          const wedgeVertices = [0, 1, 0, -3, -1, 1, 3, -1, 1, 0, -0.5, -3];
          const wedgeIndices = [0, 1, 2, 0, 2, 3, 0, 3, 1, 1, 3, 2]; // Basic tetrahedron + base
          const ship2 = this.createColoredShip(wedgeVertices, wedgeIndices);
          this.assets.titleShips.push(ship2);
          this.scene.add(ship2);

          // --- Ship 3: Boxy Freighter ---
          const boxVertices = [
            -2,
            1,
            2,
            2,
            1,
            2,
            2,
            -1,
            2,
            -2,
            -1,
            2, // Front face
            -2.5,
            1,
            -3,
            2.5,
            1,
            -3,
            2.5,
            -1,
            -3,
            -2.5,
            -1,
            -3, // Back face
          ];
          const boxIndices = [
            0,
            1,
            2,
            0,
            2,
            3, // Front
            4,
            5,
            6,
            4,
            6,
            7, // Back
            0,
            4,
            7,
            0,
            7,
            3, // Left
            1,
            5,
            6,
            1,
            6,
            2, // Right
            0,
            1,
            5,
            0,
            5,
            4, // Top
            3,
            2,
            6,
            3,
            6,
            7, // Bottom
          ];
          const ship3 = this.createColoredShip(boxVertices, boxIndices);
          this.assets.titleShips.push(ship3);
          this.scene.add(ship3);

          // --- Ship 4: Long Thin Scout ---
          const scoutVertices = [
            0,
            0.5,
            3,
            -0.5,
            -0.5,
            2,
            0.5,
            -0.5,
            2, // Front point
            0,
            0.5,
            -3,
            -0.5,
            -0.5,
            -3,
            0.5,
            -0.5,
            -3, // Back ends
          ];
          const scoutIndices = [
            0,
            1,
            2, // Front tri
            3,
            4,
            5, // Back tri
            0,
            3,
            4,
            0,
            4,
            1, // Top Left side
            0,
            2,
            5,
            0,
            5,
            3, // Top Right side
            1,
            4,
            5,
            1,
            5,
            2, // Bottom
          ];
          const ship4 = this.createColoredShip(scoutVertices, scoutIndices);
          this.assets.titleShips.push(ship4);
          this.scene.add(ship4);

          // --- Planet (Unchanged) ---
          const planetGeometry = new THREE.SphereGeometry(4, 16, 12);
          const planetMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
          });
          this.assets.planet = new THREE.Mesh(planetGeometry, planetMaterial);
          this.assets.planet.visible = false;
          this.scene.add(this.assets.planet);

          // Starfield
          const starVertices = [];
          for (let i = 0; i < 2000; i++) {
            const x = THREE.MathUtils.randFloatSpread(1000);
            const y = THREE.MathUtils.randFloatSpread(1000);
            const z = THREE.MathUtils.randFloatSpread(1000);
            if (Math.sqrt(x * x + y * y + z * z) > 100)
              starVertices.push(x, y, z); // Ensure somewhat distant
          }
          const starGeometry = new THREE.BufferGeometry();
          starGeometry.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(starVertices, 3)
          );
          const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.5,
            sizeAttenuation: false,
          });
          this.assets.stars = new THREE.Points(starGeometry, starMaterial);
          this.assets.stars.visible = false; // Start hidden
          this.scene.add(this.assets.stars);

          // Undocking Squares
          const squareGeom = new THREE.PlaneGeometry(1, 1);
          const squareMat = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            side: THREE.DoubleSide,
            wireframe: true,
          });
          for (let i = 0; i < 10; i++) {
            const square = new THREE.Mesh(squareGeom, squareMat);
            square.scale.set((i + 1) * 2, (i + 1) * 2, 1);
            square.position.z = -i * 5;
            square.visible = false; // Start hidden
            this.scene.add(square);
            this.assets.undockingSquares.push(square);
          }
        }

        switchScene(sceneName) {
          if (this.currentScene) {
            this.currentScene.exit();
          }
          if (this.scenes[sceneName]) {
            this.currentSceneName = sceneName;
            this.currentScene = this.scenes[sceneName];
            this.currentScene.enter();
          } else {
            console.error(`Scene "${sceneName}" not found!`);
          }
        }

        animate() {
          requestAnimationFrame(this.animate);
          const deltaTime = this.clock.getDelta();
          if (this.currentScene) {
            this.currentScene.update(deltaTime);
          }
          this.renderer.render(this.scene, this.camera);
        }

        onWindowResize() {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        }

        handleGlobalInput(event) {
          // Delegate input to the current scene if it implements handleInput
          if (
            this.currentScene &&
            typeof this.currentScene.handleInput === "function"
          ) {
            this.currentScene.handleInput(event);
          }
        }
      }

      // --- Start the game ---
      const game = new Game();
      game.init();
    </script>
  </body>
</html>
