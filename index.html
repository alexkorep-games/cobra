<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Project Cobra</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        color: #ffff00; /* Bright Yellow */
        font-family: "Press Start 2P", cursive;
        font-size: 10px; /* Base size, scale as needed */
        line-height: 1.6;
      }

      #container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        image-rendering: pixelated; /* Attempt pixelated look */
        image-rendering: crisp-edges;
      }

      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        pointer-events: none; /* Allow clicks through to canvas if needed */
        box-sizing: border-box;
        padding: 10px;
      }

      .top-bar,
      .bottom-bar {
        width: 100%;
        box-sizing: border-box;
      }

      .top-bar {
        text-align: center;
        padding: 5px 0;
        border-bottom: 2px solid #ffff00; /* Yellow border */
        margin-bottom: 10px;
      }

      .center-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        font-size: 1.5em;
        color: #00ff00; /* Bright Green */
        width: 80%; /* Prevent very long lines */
      }
      .center-text.small {
        font-size: 1.2em;
        line-height: 1.8;
        color: #ffffff; /* White for credits/stats */
      }

      .bottom-bar {
        border: 2px solid #ffff00; /* Yellow border */
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: space-between;
        padding: 5px;
        min-height: 80px; /* Adjust as needed */
      }

      /* --- HUD Styles (unchanged from original) --- */
      .hud-left,
      .hud-right {
        display: flex;
        flex-direction: column;
        width: 30%;
        border: 1px solid #00ff00; /* Green border */
        padding: 3px;
        font-size: 0.8em;
      }
      .hud-center {
        width: 35%;
        border: 1px solid #ffff00; /* Yellow border */
        display: flex;
        justify-content: center;
        align-items: center;
        background-image: radial-gradient(#003300 1px, transparent 1px),
          radial-gradient(#003300 1px, transparent 1px);
        background-size: 10px 10px;
        background-position: 0 0, 5px 5px;
      }
      .scanner-shape {
        width: 60%;
        height: 60%;
        border: 1px solid #ffff00;
        position: relative;
      }
      .scanner-shape::before,
      .scanner-shape::after {
        content: "";
        position: absolute;
        border-top: 1px solid #ffff00;
        left: 10%;
        right: 10%;
      }
      .scanner-shape::before {
        top: 30%;
      }
      .scanner-shape::after {
        bottom: 0%;
        width: 30%;
        left: 35%;
      }
      .hud-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 1px;
        white-space: nowrap;
      }
      .hud-label {
        color: #ff0000;
        margin-right: 5px;
      }
      .hud-bar {
        flex-grow: 1;
        border: 1px solid #004400;
        background-color: #002200;
        position: relative;
        height: 6px;
        margin-top: 2px;
      }
      .hud-bar-fill {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        background-color: #00ff00;
      }
      .hud-bar-fill.red {
        background-color: #ff0000;
      }
      .hud-value {
        color: #00ff00;
      }
      #fore-shield-fill {
        width: 80%;
      }
      #aft-shield-fill {
        width: 80%;
      }
      #fuel-fill {
        width: 100%;
      }
      #cabin-temp-fill {
        width: 10%;
        background-color: #00ff00;
      }
      #laser-temp-fill {
        width: 5%;
        background-color: #ff0000;
      }
      /* --- End HUD Styles --- */

      /* Style for the new loader screen */
      #loader-screen {
        /* Uses center-text positioning */
        color: #00ff00; /* Green like other messages */
        font-size: 1.5em; /* Match other center text */
      }

      #loader-continue-text {
        margin-top: 20px; /* Space between loading and continue text */
        font-size: 0.8em; /* Smaller prompt */
        color: #ffff00; /* Yellow prompt */
      }

      @keyframes blink-animation {
        50% {
          opacity: 0;
        }
      }

      .hidden {
        display: none;
      }

      /* Commander Stats Styling */
      #stats-screen {
        color: #cc66ff; /* Magenta-like color */
        background-color: #000000;
        border: 2px solid #cc66ff;
        padding: 20px;
        font-size: 1.2em;
        box-sizing: border-box;
      }
      #stats-screen h2 {
        color: #ffffff;
        text-align: center;
        margin-top: 0;
        margin-bottom: 15px;
      }
      #stats-screen p {
        margin: 5px 0;
      }
      #stats-screen strong {
        color: #00ff00;
        margin-right: 10px;
        display: inline-block;
        min-width: 120px;
      }
      #stats-screen .equipment {
        margin-top: 15px;
        color: #ffff00;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="eliteCanvas"></canvas>

      <div class="overlay">
        <div class="top-bar">
          <span id="title-text">--- PROJECT COBRA ---</span>
          <span id="bounty-text" class="hidden">BOUNTY: 5.0 Cr</span>
          <span id="view-text" class="hidden">Front View</span>
        </div>

        <!-- Loader Screen -->
        <div id="loader-screen" class="center-text hidden">
          <p id="loader-progress-text">LOADING...</p>
          <p id="loader-continue-text" class="hidden">
            GAME LOADED<br />
            PRESS ANY KEY TO CONTINUE
          </p>
        </div>

        <!-- Central Text Area -->
        <div id="press-key-text" class="center-text hidden">
          Press any key to start game
        </div>
        <div id="credits-text" class="center-text small hidden">
          Game Copyright:-<br />
          Bell & Braben<br />
          Code Copyright:-<br />
          Realtime Games<br />
          Software Ltd<br />
          Written by:-<br />
          Andy Onions<br />
          Cracked by:-<br />
          Key Software
        </div>
        <div id="stats-screen" class="center-text small hidden">
          <h2>COMMANDER JAMESON</h2>
          <p><strong>System:</strong> LAVE</p>
          <p><strong>Hypersystem:</strong> LAVE</p>
          <p><strong>Fuel:</strong> 7.0 Light Years</p>
          <p><strong>Cash:</strong> 100.0 Credits</p>
          <p><strong>Legal Status:</strong> Clean</p>
          <p><strong>Rating:</strong> Harmless</p>
          <p class="equipment"><strong>EQUIPMENT:</strong></p>
          <p>Missile (3)</p>
          <p>Pulse Laser (Fore)</p>
        </div>
        <div id="leaving-text" class="center-text small hidden">
          Leaving Space Station
        </div>

        <!-- Bottom HUD (always visible for now) -->
        <div class="bottom-bar">
          <div class="hud-left">
            <div class="hud-item">
              <span class="hud-label">FORE-SHIELD</span>
              <div class="hud-bar">
                <div id="fore-shield-fill" class="hud-bar-fill"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">AFT-SHIELD</span>
              <div class="hud-bar">
                <div id="aft-shield-fill" class="hud-bar-fill"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">FUEL</span>
              <div class="hud-bar">
                <div id="fuel-fill" class="hud-bar-fill"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">CABIN TEMP</span>
              <div class="hud-bar">
                <div id="cabin-temp-fill" class="hud-bar-fill"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">LASER TEMP</span>
              <div class="hud-bar">
                <div id="laser-temp-fill" class="hud-bar-fill red"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">ALTITUDE</span>
              <div class="hud-bar"></div>
            </div>
            <div class="hud-item">
              <span class="hud-label">MISSILES</span
              ><span class="hud-value"> M M M M</span>
            </div>
          </div>
          <div class="hud-center"><div class="scanner-shape"></div></div>
          <div class="hud-right">
            <div class="hud-item">
              <span class="hud-label">SPEED</span>
              <div class="hud-bar">
                <div class="hud-bar-fill" style="width: 10%"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">ROLL</span>
              <div class="hud-bar">
                <div class="hud-bar-fill" style="width: 50%"></div>
              </div>
            </div>
            <div class="hud-item">
              <span class="hud-label">DIVE/CLIMB</span>
              <div class="hud-bar">
                <div class="hud-bar-fill" style="width: 50%"></div>
              </div>
            </div>
            <div
              class="hud-item"
              style="justify-content: center; margin-top: 5px"
            >
              <span style="border: 1px solid #00ff00; padding: 2px 5px">1</span>
              <span
                style="
                  border: 1px solid #00ff00;
                  padding: 2px 5px;
                  margin: 0 5px;
                "
                >2</span
              >
              <span style="border: 1px solid #00ff00; padding: 2px 5px">3</span>
              <span
                style="
                  border: 1px solid #ffff00;
                  border-radius: 50%;
                  width: 15px;
                  height: 15px;
                  display: inline-block;
                  margin-left: 10px;
                "
              ></span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Audio Elements -->
    <audio id="introMusic" loop>
      <source src="assets/elite_intro_music.mp3" type="audio/mpeg" />
      Your browser does not support the audio element. (Needs
      elite_intro_music.mp3)
    </audio>
    <audio id="undockSound">
      <source src="assets/undocking_sound.mp3" type="audio/mpeg" />
      Your browser does not support the audio element. (Needs
      undocking_sound.mp3)
    </audio>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

      // --- Constants ---
      const SHIP_DISPLAY_DURATION = 10.0; // Seconds

      // --- Base Scene Class ---
      class SceneBase {
        constructor(game) {
          this.game = game;
          this.scene = game.scene;
          this.camera = game.camera;
          this.renderer = game.renderer;
          this.inputProcessed = false; // Flag to prevent multiple inputs per scene transition
        }
        enter() {
          console.log(`Entering ${this.constructor.name}`);
          this.inputProcessed = false; // Reset input flag on entering
        }
        exit() {
          console.log(`Exiting ${this.constructor.name}`);
        }
        update(deltaTime) {}
        handleInput(event) {}
      }

      // --- Loader Scene --- NEW SCENE
      class LoaderScene extends SceneBase {
        constructor(game) {
          super(game);
          this.loaderScreen = game.domElements.loaderScreen;
          this.loaderProgressText = game.domElements.loaderProgressText;
          this.loaderContinueText = game.domElements.loaderContinueText;
          this.stars = game.assets.stars; // Access stars
          this.readyToContinue = false;
        }

        enter() {
          super.enter();
          this.loaderScreen.classList.remove("hidden");
          this.loaderProgressText.classList.remove("hidden");
          this.loaderContinueText.classList.add("hidden"); // Hide continue prompt initially
          this.readyToContinue = false;

          // Show stars during loading
          if (this.stars) {
            this.stars.visible = true;
          }

          // Hide other central text elements that might be visible
          this.game.domElements.pressKeyText.classList.add("hidden");
          this.game.domElements.creditsText.classList.add("hidden");
          this.game.domElements.statsScreen.classList.add("hidden");
          this.game.domElements.leavingText.classList.add("hidden");

          // Hide specific UI elements not needed yet
          this.game.domElements.titleText.classList.remove("hidden"); // Keep title visible
          this.game.domElements.viewText.classList.add("hidden");
          this.game.domElements.bottomBar.classList.add("hidden"); // Hide HUD during loading
        }

        exit() {
          super.exit();
          this.loaderScreen.classList.add("hidden");
          this.game.domElements.bottomBar.classList.remove("hidden"); // Show HUD for next scenes
        }

        update(deltaTime) {
          // Rotate stars
          if (this.stars) {
            this.stars.rotation.y += 0.01 * deltaTime;
          }

          // Check if loading is complete (managed by Game class)
          if (!this.readyToContinue && this.game.loadingComplete) {
            this.readyToContinue = true;
            this.loaderProgressText.classList.add("hidden"); // Hide "LOADING..."
            this.loaderContinueText.classList.remove("hidden"); // Show "CLICK..."
            console.log("Assets loaded. Ready for user input.");
          }
        }

        handleInput(event) {
          // Only proceed if loading is done AND input hasn't been processed yet
          if (this.readyToContinue && !this.inputProcessed) {
            if (event.type === "keydown" || event.type === "mousedown") {
              this.inputProcessed = true; // Mark as processed
              console.log("Loader input detected, switching to title scene.");
              this.game.switchScene("title");
            }
          }
        }
      }

      // --- Title Scene ---
      class TitleScene extends SceneBase {
        constructor(game) {
          super(game);
          this.titleShips = game.assets.titleShips;
          this.planet = game.assets.planet;
          this.stars = game.assets.stars;
          this.pressKeyText = game.domElements.pressKeyText;
          this.introMusic = game.audio.introMusic;

          // --- Animation Constants ---
          this.FLY_IN_DURATION = 0.5; // seconds
          this.FLY_OUT_DURATION = 0.5; // seconds
          // Original total duration was SHIP_DISPLAY_DURATION (e.g., 10.0)
          // Calculate hold time based on the total and fly times
          this.HOLD_DURATION = Math.max(
            0,
            SHIP_DISPLAY_DURATION - this.FLY_IN_DURATION - this.FLY_OUT_DURATION
          );
          this.TOTAL_CYCLE_DURATION =
            this.FLY_IN_DURATION + this.HOLD_DURATION + this.FLY_OUT_DURATION;

          this.START_Z = -150;
          this.TARGET_POS = new THREE.Vector3(-3, 0, 0); // Final position during hold

          this.currentShipIndex = 0;
          this.shipDisplayTimer = 0;
        }

        enter() {
          super.enter();
          this.pressKeyText.classList.remove("hidden");

          // Hide all title ships initially
          this.titleShips.forEach((ship) => ship && (ship.visible = false));

          // Setup the first ship if available
          this.currentShipIndex = 0;
          this.shipDisplayTimer = 0; // Start timer for the first ship's fly-in
          this.prepareShip(this.currentShipIndex); // Prepare the first ship

          // Setup planet and stars
          this.planet.visible = true;
          this.stars.visible = true;
          this.planet.position.set(200, 0, -500);
          this.planet.scale.set(1, 1, 1);

          this.game.domElements.titleText.classList.remove("hidden");
          this.game.domElements.viewText.classList.add("hidden");
          this.game.domElements.bottomBar.classList.remove("hidden");

          // Play Intro Music
          this.introMusic.currentTime = 0;
          this.introMusic
            .play()
            .then(() => console.log("Intro music started."))
            .catch((e) =>
              console.warn(
                "Intro music play failed (likely needs interaction):",
                e
              )
            );
        }

        exit() {
          super.exit();
          this.pressKeyText.classList.add("hidden");

          // Hide the currently shown ship if it exists
          const currentShip = this.titleShips[this.currentShipIndex];
          if (currentShip) {
            currentShip.visible = false;
          }

          this.planet.visible = false;
          this.introMusic.pause();
          console.log("Intro music paused.");
        }

        // Helper to set up a ship for its animation cycle
        prepareShip(index) {
          const ship = this.titleShips[index];
          if (ship) {
            ship.position.set(
              this.TARGET_POS.x,
              this.TARGET_POS.y,
              this.START_Z
            ); // Start far away
            ship.rotation.set(0, Math.PI, 0); // Reset rotation
            ship.visible = true;
          } else {
            console.warn(`Attempted to prepare missing ship at index ${index}`);
          }
        }

        update(deltaTime) {
          // Rotate stars
          if (this.stars) {
            this.stars.rotation.y += 0.01 * deltaTime;
          }

          // Animate and cycle ships
          if (this.titleShips.length > 0) {
            this.shipDisplayTimer += deltaTime;
            const currentShip = this.titleShips[this.currentShipIndex];

            if (!currentShip) {
              // Skip missing ship immediately
              console.warn(
                `Ship at index ${this.currentShipIndex} is missing. Skipping.`
              );
              this.shipDisplayTimer = this.TOTAL_CYCLE_DURATION; // Force cycle
            } else {
              // --- Animation Logic ---
              const timer = this.shipDisplayTimer;

              if (timer < this.FLY_IN_DURATION) {
                // Phase 1: Flying In
                const t = Math.min(1, timer / this.FLY_IN_DURATION); // Progress 0 to 1
                currentShip.position.z = THREE.MathUtils.lerp(
                  this.START_Z,
                  this.TARGET_POS.z,
                  t
                );
                // Optional: subtle rotation during fly-in
                currentShip.rotation.y += 0.1 * deltaTime;
              } else if (timer < this.FLY_IN_DURATION + this.HOLD_DURATION) {
                // Phase 2: Holding
                // Ensure position is exact after fly-in lerp
                currentShip.position.z = this.TARGET_POS.z;
                // Apply regular rotation
                currentShip.rotation.y += 0.5 * deltaTime;
                currentShip.rotation.x += 0.25 * deltaTime;
              } else if (timer < this.TOTAL_CYCLE_DURATION) {
                // Phase 3: Flying Out
                const flyOutTimer =
                  timer - (this.FLY_IN_DURATION + this.HOLD_DURATION);
                const t = Math.min(1, flyOutTimer / this.FLY_OUT_DURATION); // Progress 0 to 1
                currentShip.position.z = THREE.MathUtils.lerp(
                  this.TARGET_POS.z,
                  this.START_Z,
                  t
                );
                // Optional: subtle rotation during fly-out
                currentShip.rotation.y += 0.1 * deltaTime;
              }
            }

            // --- Check for Cycle End ---
            if (this.shipDisplayTimer >= this.TOTAL_CYCLE_DURATION) {
              // Hide current ship (even if it was null)
              if (currentShip) {
                currentShip.visible = false;
              }

              // Move to next ship index
              this.currentShipIndex =
                (this.currentShipIndex + 1) % this.titleShips.length;

              // Prepare the next ship for its fly-in
              this.prepareShip(this.currentShipIndex);

              // Reset timer
              this.shipDisplayTimer = 0;
            }
          }
        }

        handleInput(event) {
          // Transition on key press
          if (
            !this.inputProcessed &&
            (event.type === "keydown" || event.type === "mousedown")
          ) {
            this.inputProcessed = true;
            this.game.switchScene("credits");
          }
        }
      }

      // --- Credits Scene (Unchanged logic, but uses base class) ---
      class CreditsScene extends SceneBase {
        constructor(game) {
          super(game);
          this.creditsText = game.domElements.creditsText;
          this.timeoutId = null;
        }

        enter() {
          super.enter();
          this.creditsText.classList.remove("hidden");
          this.game.assets.stars.visible = true;

          this.timeoutId = setTimeout(() => {
            // Check if we are still in this scene before switching
            if (this.game.currentScene === this) {
              this.game.switchScene("stats");
            }
          }, 3000);
        }

        exit() {
          super.exit();
          this.creditsText.classList.add("hidden");
          clearTimeout(this.timeoutId);
        }

        update(deltaTime) {
          if (this.game.assets.stars) {
            this.game.assets.stars.rotation.y += 0.01 * deltaTime;
          }
        }
        // No handleInput needed for automatic transition
      }

      // --- Stats Scene ---
      class StatsScene extends SceneBase {
        constructor(game) {
          super(game);
          this.statsScreen = game.domElements.statsScreen;
          this.timeoutId = null;
        }

        enter() {
          super.enter();
          this.statsScreen.classList.remove("hidden");
          this.game.assets.stars.visible = true;

          this.timeoutId = setTimeout(() => {
            if (this.game.currentScene === this) {
              this.game.switchScene("undocking");
            }
          }, 5000);
        }

        exit() {
          super.exit();
          this.statsScreen.classList.add("hidden");
          clearTimeout(this.timeoutId);
        }

        update(deltaTime) {
          if (this.game.assets.stars) {
            this.game.assets.stars.rotation.y += 0.01 * deltaTime;
          }
        }
        // No handleInput needed for automatic transition
      }

      // --- Undocking Scene ---
      class UndockingScene extends SceneBase {
        constructor(game) {
          super(game);
          this.leavingText = game.domElements.leavingText;
          this.undockSound = game.audio.undockSound;
          this.undockingSquares = game.assets.undockingSquares;
          this.timeoutId = null;
        }

        enter() {
          super.enter();
          this.leavingText.classList.remove("hidden");
          this.game.domElements.titleText.classList.add("hidden");
          this.game.domElements.viewText.classList.remove("hidden");
          this.game.assets.stars.visible = true;

          this.undockingSquares.forEach((square, i) => {
            square.position.z = -i * 5;
            square.visible = true;
          });

          this.undockSound.currentTime = 0;
          this.undockSound
            .play()
            .catch((e) => console.warn("Undock audio play failed:", e));

          this.timeoutId = setTimeout(() => {
            if (this.game.currentScene === this) {
              this.game.switchScene("space_flight");
            }
          }, 3500);
        }

        exit() {
          super.exit();
          this.leavingText.classList.add("hidden");
          this.undockingSquares.forEach((s) => (s.visible = false));
          clearTimeout(this.timeoutId);
        }

        update(deltaTime) {
          const speed = 20.0;
          this.undockingSquares.forEach((s, i) => {
            s.position.z += speed * deltaTime;
            if (s.position.z > this.camera.position.z + 5) {
              s.position.z =
                -this.undockingSquares.length * 5 +
                (5 - (s.position.z - (this.camera.position.z + 5)));
            }
          });

          if (this.game.assets.stars) {
            this.game.assets.stars.rotation.y += 0.01 * deltaTime;
          }
        }
        // No handleInput needed for automatic transition
      }

      // --- Space Flight Scene ---
      class SpaceFlightScene extends SceneBase {
        constructor(game) {
          super(game);
          this.planet = game.assets.planet;
          this.stars = game.assets.stars;
        }

        enter() {
          super.enter();
          this.game.domElements.titleText.classList.add("hidden");
          this.game.domElements.viewText.classList.remove("hidden");

          // Position planet as a distant object
          this.planet.position.set(0, 15, -60); // Further away, slightly up
          this.planet.scale.set(5, 5, 5); // Make it look larger/closer than a star
          this.planet.visible = true;
          this.stars.visible = true;

          console.log("Entered Space Flight Scene. Intro sequence complete.");
          // Future: Enable player controls, AI, etc.
        }

        exit() {
          super.exit();
          this.planet.visible = false; // Hide if transitioning elsewhere
        }

        update(deltaTime) {
          // Keep stars rotating slowly
          if (this.stars) {
            this.stars.rotation.y += 0.01 * deltaTime;
          }
          // Maybe add slow drift to planet or other background elements
        }
      }

      // --- Game Manager Class ---
      class Game {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.clock = new THREE.Clock();

          this.assets = {
            titleShips: [], // Will be populated by loader
            planet: null,
            stars: null,
            undockingSquares: [],
          };

          // --- Asset Loading Tracking ---
          this.assetsToLoad = 0;
          this.assetsLoaded = 0;
          this.loadingComplete = false; // Flag for LoaderScene

          this.audio = {
            introMusic: null,
            undockSound: null,
          };

          this.domElements = {
            loaderScreen: document.getElementById("loader-screen"), // New
            loaderProgressText: document.getElementById("loader-progress-text"), // New
            loaderContinueText: document.getElementById("loader-continue-text"), // New
            pressKeyText: document.getElementById("press-key-text"),
            creditsText: document.getElementById("credits-text"),
            statsScreen: document.getElementById("stats-screen"),
            leavingText: document.getElementById("leaving-text"),
            titleText: document.getElementById("title-text"),
            viewText: document.getElementById("view-text"),
            bottomBar: document.querySelector(".bottom-bar"), // Reference to hide/show HUD
          };

          this.scenes = {};
          this.currentScene = null;
          this.currentSceneName = null;

          this.animate = this.animate.bind(this);
          this.onWindowResize = this.onWindowResize.bind(this);
          this.handleGlobalInput = this.handleGlobalInput.bind(this);
        }

        init() {
          // Core Three.js Setup
          this.scene = new THREE.Scene();
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.camera.position.z = 15;

          const canvas = document.getElementById("eliteCanvas");
          this.renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: false,
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setClearColor(0x000000);

          // Lighting
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
          this.scene.add(ambientLight);
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
          directionalLight.position.set(1, 1, 1);
          this.scene.add(directionalLight);

          // --- Load Assets (including tracking) ---
          this.createAssets(); // This now starts the loading process

          // --- Audio ---
          this.audio.introMusic = document.getElementById("introMusic");
          this.audio.undockSound = document.getElementById("undockSound");

          // Instantiate Scenes (including Loader)
          this.scenes.loader = new LoaderScene(this); // Instantiate Loader first
          this.scenes.title = new TitleScene(this);
          this.scenes.credits = new CreditsScene(this);
          this.scenes.stats = new StatsScene(this);
          this.scenes.undocking = new UndockingScene(this);
          this.scenes.space_flight = new SpaceFlightScene(this);

          // Event Listeners
          window.addEventListener("resize", this.onWindowResize, false);
          window.addEventListener("keydown", this.handleGlobalInput, false);
          window.addEventListener("mousedown", this.handleGlobalInput, false); // Add mouse click listener

          // --- Start with the Loader Scene ---
          this.switchScene("loader");
          this.animate();
        }

        createAssets() {
          const loader = new GLTFLoader();
          const shipFilePaths = [
            "assets/ships/ship-cobra.gltf",
            "assets/ships/ship-pirate.gltf",
            "assets/ships/asteroid.gltf",
          ];
          const shipScale = 6;

          // --- Setup Loading Tracking ---
          this.assetsToLoad = shipFilePaths.length; // Expect this many ships
          this.assetsLoaded = 0;
          this.loadingComplete = false;
          this.assets.titleShips = new Array(this.assetsToLoad); // Pre-allocate array to maintain order

          console.log(`Expecting ${this.assetsToLoad} ship assets.`);

          // --- Load Static Assets (Planet, Stars, Squares) ---
          // These are created synchronously, so don't need tracking for the *loader* specifically
          // Planet
          const planetGeometry = new THREE.SphereGeometry(160, 16, 12);
          const planetMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
          });
          this.assets.planet = new THREE.Mesh(planetGeometry, planetMaterial);
          this.assets.planet.visible = false;
          this.scene.add(this.assets.planet);

          // Starfield
          const starVertices = [];
          for (let i = 0; i < 2000; i++) {
            const x = THREE.MathUtils.randFloatSpread(4000);
            const y = THREE.MathUtils.randFloatSpread(4000);
            const z = THREE.MathUtils.randFloatSpread(4000);
            if (Math.sqrt(x * x + y * y + z * z) > 100)
              starVertices.push(x, y, z);
          }
          const starGeometry = new THREE.BufferGeometry();
          starGeometry.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(starVertices, 3)
          );
          const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.5,
            sizeAttenuation: false,
          });
          this.assets.stars = new THREE.Points(starGeometry, starMaterial);
          this.assets.stars.visible = false;
          this.scene.add(this.assets.stars);

          // Undocking Squares
          const squareGeom = new THREE.PlaneGeometry(1, 1);
          const squareMat = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            side: THREE.DoubleSide,
            wireframe: true,
          });
          this.assets.undockingSquares = [];
          for (let i = 0; i < 10; i++) {
            const square = new THREE.Mesh(squareGeom, squareMat);
            square.scale.set((i + 1) * 2, (i + 1) * 2, 1);
            square.position.z = -i * 5;
            square.visible = false;
            this.scene.add(square);
            this.assets.undockingSquares.push(square);
          }

          // --- Load Ship Models Asynchronously ---
          shipFilePaths.forEach((path, index) => {
            loader.load(
              path,
              // onLoad
              (gltf) => {
                console.log(`Successfully loaded ${path}`);
                const loadedShip = gltf.scene;
                loadedShip.scale.set(shipScale, shipScale, shipScale);
                loadedShip.visible = false; // Start hidden

                // Optional: Ensure material (can customize per ship later)
                loadedShip.traverse((child) => {
                  if (child.isMesh) {
                    // Example: Give basic wireframe material if none exists
                    if (
                      !child.material ||
                      child.material.type === "MeshStandardMaterial"
                    ) {
                      // Check if it needs a basic material
                      child.material = new THREE.MeshBasicMaterial({
                        color: 0xffff00, // Yellow
                        wireframe: true,
                      });
                    } else if (child.material.wireframe !== undefined) {
                      child.material.wireframe = false;
                    }
                  }
                });

                this.scene.add(loadedShip);
                this.assets.titleShips[index] = loadedShip; // Store in pre-allocated array slot

                this.checkLoadingComplete(); // Check if all assets are loaded
              },
              // onProgress (optional)
              undefined, //(xhr) => { console.log(`${path}: ${(xhr.loaded / xhr.total * 100)}% loaded`); },
              // onError
              (error) => {
                console.error(`Error loading ${path}:`, error);
                this.assets.titleShips[index] = null; // Mark slot as failed/empty
                this.checkLoadingComplete(); // Still need to count this attempt
              }
            );
          });

          // Check completion immediately in case there were 0 ships to load
          if (this.assetsToLoad === 0) {
            this.checkLoadingComplete();
          }
        }

        // --- Helper to check loading status ---
        checkLoadingComplete() {
          this.assetsLoaded++;
          console.log(
            `Assets loaded: ${this.assetsLoaded}/${this.assetsToLoad}`
          );
          if (this.assetsLoaded >= this.assetsToLoad && !this.loadingComplete) {
            this.loadingComplete = true;
            console.log(
              "All ship assets processed (loaded or failed). Loader can proceed."
            );
            // The LoaderScene will detect this change in its update loop
          }
        }

        switchScene(sceneName) {
          if (this.currentScene) {
            this.currentScene.exit();
          }
          if (this.scenes[sceneName]) {
            this.currentSceneName = sceneName;
            this.currentScene = this.scenes[sceneName];
            this.currentScene.enter(); // Enter the new scene
          } else {
            console.error(`Scene "${sceneName}" not found!`);
          }
        }

        animate() {
          requestAnimationFrame(this.animate);
          const deltaTime = this.clock.getDelta();
          if (this.currentScene) {
            this.currentScene.update(deltaTime);
          }
          this.renderer.render(this.scene, this.camera);
        }

        onWindowResize() {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        }

        handleGlobalInput(event) {
          // Prevent default browser action for spacebar, arrows etc. if needed in game
          // if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {
          //     event.preventDefault();
          // }

          // Delegate input to the current scene
          if (
            this.currentScene &&
            typeof this.currentScene.handleInput === "function"
          ) {
            this.currentScene.handleInput(event);
          }
        }
      }

      // --- Start the game ---
      const game = new Game();
      // Ensure assets folder and ship files (or placeholders) exist
      // Ensure elite_intro_music.mp3 and undocking_sound.mp3 are in assets/
      game.init();
    </script>
  </body>
</html>
